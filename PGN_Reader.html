<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <title>Reno Chess Club - PGN Reader</title>
  <style>
    /* Override the shared CSS to allow scrolling on this page */
    html, body {
      height: auto !important;
      min-height: 100vh;
      overflow-y: auto !important;
      overflow-x: hidden;
    }

    /* PGN Reader specific styles */
    .pgn-container {
      max-width: 1400px;
      margin: 2rem auto;
      padding: 1rem;
      background-color: rgba(242, 242, 242, 0.95);
      border-radius: 1rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .pgn-header {
      color: var(--primary-dark-color);
      margin-bottom: 1.5rem;
      font-size: 2rem;
      text-align: center;
    }

    .pgn-layout {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-top: 1rem;
    }

    .board-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f2f2f2;
      padding: 1rem;
      border-radius: 0.5rem;
    }

    .chessboard {
      width: 100%;
      max-width: 500px;
      aspect-ratio: 1;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      border: 3px solid var(--primary-dark-color);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      margin-bottom: 1rem;
      background-color: #ccb89a;
      position: relative;
      z-index: 1;
    }

    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      cursor: pointer;
      user-select: none;
    }

    .square.light {
      background-color: #ccb89a;
    }

    .square.dark {
      background-color: #9a7454;
    }

    .square.highlight {
      background-color: rgba(255, 255, 0, 0);
    }

    /* Make non-pawn pieces 15% larger */
    .square .piece-king,
    .square .piece-queen,
    .square .piece-rook,
    .square .piece-bishop,
    .square .piece-knight {
      font-size: 1.15em;
    }

    .controls {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    .control-btn {
      background-color: var(--accent-color);
      color: var(--primary-color);
      border: 2px solid var(--accent-color);
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: bold;
    }

    .control-btn:hover {
      background-color: var(--secondary-color);
      border-color: var(--primary-dark-color);
    }

    .control-btn:disabled {
      background-color: #ccc;
      border-color: #999;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .control-btn.active {
      background-color: #28a745;
      border-color: #1e7e34;
    }

    .control-btn.active:hover {
      background-color: #218838;
    }

    .moves-section {
      display: flex;
      flex-direction: column;
    }

    .game-selector {
      margin-bottom: 1rem;
    }

    .game-selector label {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--primary-dark-color);
      font-weight: bold;
      font-size: 1.1rem;
    }

    .game-selector select {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid var(--accent-color);
      border-radius: 0.5rem;
      font-size: 1rem;
      background-color: white;
      cursor: pointer;
    }

    .pgn-input-area {
      margin-bottom: 1rem;
    }

    .pgn-input-area label {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--primary-dark-color);
      font-weight: bold;
      font-size: 1.1rem;
    }

    .pgn-textarea {
      width: 100%;
      min-height: 150px;
      padding: 1rem;
      border: 2px solid var(--accent-color);
      border-radius: 0.5rem;
      font-family: monospace;
      font-size: 0.95rem;
      resize: vertical;
      background-color: white;
    }

    .pgn-buttons {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .load-btn, .clear-btn {
      background-color: var(--secondary-color);
      color: var(--primary-color);
      border: 2px solid var(--secondary-color);
      padding: 0.75rem 2rem;
      border-radius: 0.5rem;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: bold;
      flex: 1;
    }

    .load-btn:hover, .clear-btn:hover {
      background-color: var(--accent-color);
      border-color: var(--primary-dark-color);
    }

    .game-info {
      background-color: rgba(217, 161, 113, 0.2);
      padding: 1rem;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
      border: 2px solid var(--accent-color);
    }

    .game-info p {
      margin: 0.5rem 0;
      color: var(--primary-dark-color);
      font-size: 1rem;
    }

    .game-info strong {
      color: var(--secondary-color);
    }

    .analysis-panel {
      background-color: rgba(40, 167, 69, 0.1);
      border: 2px solid #28a745;
      border-radius: 0.5rem;
      padding: 1rem;
      margin-top: 1rem;
      width: 100%;
      max-width: 500px;
      display: none;
    }

    .analysis-panel.active {
      display: block;
    }

    .analysis-panel h3 {
      margin: 0 0 0.5rem 0;
      color: #28a745;
      font-size: 1.1rem;
    }

    .analysis-panel p {
      margin: 0.25rem 0;
      color: var(--primary-dark-color);
      font-size: 0.95rem;
    }

    .analysis-status {
      font-style: italic;
      color: #666;
      font-size: 0.9rem;
    }

    .moves-display {
      background-color: white;
      border: 2px solid var(--accent-color);
      border-radius: 0.5rem;
      padding: 1rem;
      min-height: 300px;
      max-height: 500px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.95rem;
      line-height: 1.8;
      letter-spacing: normal;
    }

    .move-number {
      color: var(--secondary-color);
      font-weight: bold;
      margin-right: 0.5rem;
    }

    .move {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      margin: 0.15rem;
      cursor: pointer;
      border-radius: 0.25rem;
      transition: background-color 0.2s;
    }

    .move:hover {
      background-color: var(--accent-color);
      color: var(--primary-color);
    }

    .move.current {
      background-color: var(--accent-color);
      color: var(black); /*--primary-color*/
      font-weight: bold;
    }

    .move.variation {
      background-color: rgba(166, 101, 63, 0.15);
      font-style: italic;
    }

    .move.variation:hover {
      background-color: var(--secondary-color);
      color: var(--primary-color);
    }

    .variation-group {
      display: inline-block;
      margin-left: 1rem;
      padding: 0.25rem;
      border-left: 2px solid var(--accent-color);
      padding-left: 0.5rem;
    }

    .move-comment {
      display: inline;
      color: #666;
      font-style: italic;
      font-size: 0.9em;
      margin-left: 0.25rem;
      margin-right: 0.25rem;
    }

    .last-move {
      background-color: rgba(217, 161, 113, 0.3) !important;
      font-weight: bold;
    }

    .error-message {
      background-color: #fadbd8;
      color: #c0392b;
      padding: 1rem;
      border-radius: 0.5rem;
      margin: 1rem 0;
      border: 2px solid #c0392b;
    }

    .footer-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
      max-width: 600px;
      margin: 2rem auto 1rem;
    }

    .footer-buttons .button1,
    .footer-buttons .button5 {
      flex: 1;
    }

    @media (max-width: 968px) {
      .pgn-layout {
        grid-template-columns: 1fr;
      }

      .chessboard {
        max-width: 400px;
      }

      .square {
        font-size: 2rem;
      }
    }

    @media (max-width: 480px) {
      .chessboard {
        max-width: 100%;
      }

      .square {
        font-size: 1.5rem;
      }

      .control-btn {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
<header>
    <h1><a class="return-home" href="index.html">Reno Chess Club</a></h1>
    <h2><a class="address" target="_blank" rel="noopener noreferrer" href="https://www.google.com/search?q=125+west+plumb+lane+reno+nv">125 West Plumb Lane</a></h2>
    <h2><a class="address" target="_blank" rel="noopener noreferrer" href="https://www.google.com/search?q=125+west+plumb+lane+reno+nv">Reno, Nevada 89502</a></h2>
    <h2 class="phone-number">775-355-1802</h2>
    <h2>Thursdays 5:30pm-Midnight</h2>
</header>

<div class="pgn-container">
    <h2 class="pgn-header">Game Viewer</h2>
    
    <div class="pgn-layout">
        <!-- Board Section -->
        <div class="board-section">
            <div id="chessboard" class="chessboard"></div>
            <div class="controls">
                <button class="control-btn" id="startBtn">‚èÆ Start</button>
                <button class="control-btn" id="prevBtn">‚óÄ Previous</button>
                <button class="control-btn" id="nextBtn">Next ‚ñ∂</button>
                <button class="control-btn" id="endBtn">End ‚è≠</button>
                <button class="control-btn" id="flipBtn">üîÑ Flip Board</button>
                <button class="control-btn" id="analysisBtn">üîç Analysis</button>
            </div>
            
            <!-- Analysis Panel under the board -->
            <div id="analysisPanel" class="analysis-panel">
                <h3>Stockfish Analysis</h3>
                <p class="analysis-status" id="analysisStatus">Click Analysis to start</p>
                <p id="analysisEval">Evaluation: --</p>
                <p id="analysisBestMove">Best move: --</p>
                <p id="analysisDepth">Depth: 0</p>
            </div>
        </div>

        <!-- Moves Section -->
        <div class="moves-section">
            <div class="game-selector">
                <label for="gameSelect">Select a game:</label>
                <select id="gameSelect">
                    <option value="">-- Choose a game or paste PGN below --</option>
                </select>
            </div>

            <div class="pgn-input-area">
                <label for="pgnInput">Or paste PGN notation here:</label>
                <textarea id="pgnInput" class="pgn-textarea" placeholder="[Event &quot;Example Game&quot;]
[White &quot;Player 1&quot;]
[Black &quot;Player 2&quot;]

1. e4 e5 2. Nf3 Nc6 3. Bb5..."></textarea>
                <div class="pgn-buttons">
                    <button class="load-btn" id="loadBtn">Load Game</button>
                    <button class="clear-btn" id="clearBtn">Clear</button>
                </div>
            </div>

            <div id="gameInfo" class="game-info" style="display: none;"></div>

            <div id="movesDisplay" class="moves-display"></div>
        </div>
    </div>
</div>

<div class="footer-buttons">
    <a class="button1" href="index.html">Home</a>
    <a class="button2" href="Contact.html">Contact</a>
</div>

<footer>
    <h4>Copyright ¬© 2026 Reno Chess Club. All rights reserved.</h4>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script>
// ============================================================
// GAME DATABASE
// ============================================================
const GAME_DATABASE = [
    {
        name: "Kasparov vs Topalov - 1999 (Wijk aan Zee)",
        pgn: `[Event "Hoogovens A Tournament"]
[Site "Wijk aan Zee NED"]
[Date "1999.01.20"]
[Round "4"]
[White "Garry Kasparov"]
[Black "Veselin Topalov"]
[Result "1-0"]

1. e4 d6 2. d4 Nf6 3. Nc3 g6 4. Be3 Bg7 5. Qd2 c6 6. f3 b5 7. Nge2 Nbd7 8. Bh6 Bxh6 9. Qxh6 Bb7 10. a3 e5 11. O-O-O Qe7 12. Kb1 a6 13. Nc1 O-O-O 14. Nb3 exd4 15. Rxd4 c5 16. Rd1 Nb6 17. g3 Kb8 18. Na5 Ba8 19. Bh3 d5 20. Qf4+ Ka7 21. Rhe1 d4 22. Nd5 Nbxd5 23. exd5 Qd6 24. Rxd4 cxd4 25. Re7+ Kb6 26. Qxd4+ Kxa5 27. b4+ Ka4 28. Qc3 Qxd5 29. Ra7 Bb7 30. Rxb7 Qc4 31. Qxf6 Kxa3 32. Qxa6+ Kxb4 33. c3+ Kxc3 34. Qa1+ Kd2 35. Qb2+ Kd1 36. Bf1 Rd2 37. Rd7 Rxd7 38. Bxc4 bxc4 39. Qxh8 Rd3 40. Qa8 c3 41. Qa4+ Ke1 42. f4 f5 43. Kc1 Rd2 44. Qa7 1-0`
    },
    {
        name: "Fischer vs Spassky - 1972 (Game 6)",
        pgn: `[Event "World Championship"]
[Site "Reykjavik ISL"]
[Date "1972.07.23"]
[Round "6"]
[White "Robert James Fischer"]
[Black "Boris Spassky"]
[Result "1-0"]

1. c4 e6 2. Nf3 d5 3. d4 Nf6 4. Nc3 Be7 5. Bg5 O-O 6. e3 h6 7. Bh4 b6 8. cxd5 Nxd5 9. Bxe7 Qxe7 10. Nxd5 exd5 11. Rc1 Be6 12. Qa4 c5 13. Qa3 Rc8 14. Bb5 a6 15. dxc5 bxc5 16. O-O Ra7 17. Be2 Nd7 18. Nd4 Qf8 19. Nxe6 fxe6 20. e4 d4 21. f4 Qe7 22. e5 Rb8 23. Bc4 Kh8 24. Qh3 Nf8 25. b3 a5 26. f5 exf5 27. Rxf5 Nh7 28. Rcf1 Qd8 29. Qg3 Re7 30. h4 Rbb7 31. e6 Rbc7 32. Qe5 Qe8 33. a4 Qd8 34. R1f2 Qe8 35. R2f3 Qd8 36. Bd3 Qe8 37. Qe4 Nf6 38. Rxf6 gxf6 39. Rxf6 Kg8 40. Bc4 Kh8 41. Qf4 1-0`
    },
    {
        name: "Morphy vs Duke of Brunswick - 1858 (Opera Game)",
        pgn: `[Event "Paris Opera"]
[Site "Paris FRA"]
[Date "1858.??.??"]
[Round "?"]
[White "Paul Morphy"]
[Black "Duke Karl / Count Isouard"]
[Result "1-0"]

1. e4 e5 2. Nf3 d6 3. d4 Bg4 4. dxe5 Bxf3 5. Qxf3 dxe5 6. Bc4 Nf6 7. Qb3 Qe7 8. Nc3 c6 9. Bg5 b5 10. Nxb5 cxb5 11. Bxb5+ Nbd7 12. O-O-O Rd8 13. Rxd7 Rxd7 14. Rd1 Qe6 15. Bxd7+ Nxd7 16. Qb8+ Nxb8 17. Rd8# 1-0`
    },
    {
        name: "Club Qualifier - 2026 (Reno Chess Club)",
        pgn: `[Event "Club Qualifier"]
[Site "Reno Chess Club"]
[Date "2026.02.05"]
[Round "4"]
[White "Eli Kaufman"]
[Black "A. Gold"]
[Result "0-1"]
[TimeControl "g/90 +30"]
[Link "https://www.chess.com/analysis/game/pgn/2rLPpFYJqt/analysis?move=43"]

1. c4 {So much for the anticipated Jobava.} 1... c6 2. d4 d5 3. Nc3 Nf6 4. cxd5 cxd5 5. f3 {Certainly one way to make the exchange Slav exciting.} 5... e6 6. e4 Bb4 7. e5 Nfd7 8. Be3 O-O 9. f4 f6 {With Black being better developed, I thought opening the position was called for. The engine rolls its eyes.} 10. Qg4 Qe7 {Holds the pawn, communicates with the bishop, reinforces the second rank. Man, the engine is a harsh mistress.} ({The engine notes} 10... Qa5 11. Qxe6+ $4 Kh8 12. Qh3 Bxc3+ 13. bxc3 Qxc3+) 11. Nf3 b6 (11... Nb6 12. a3 Nc4) 12. Bd3 (12. Rc1 Ba6 13. a3 Bxc3+ 14. Rxc3 Bxf1 15. Rxf1 Na6 $14) 12... Ba6 13. Bxh7+ $2 Kxh7 14. Qh5+ Kg8 15. Nh4 {When I had played 12 Ba6, I had looked at the bishop sac, but had not considered Nh4. So I guessed I needed to consider what Ng6 could bring.} 15... Bxc3+ (15... Nc6 16. Ng6 Bxc3+ {transposes, though I didn't see it at the time.}) 16. bxc3 Qa3 17. Ng6 Nc6 (17... Rc8 {seemed materialistic. Instead, I complete development.}) 18. f5 {And the Kid goes for broke.} (18. Bd2 fxe5) 18... fxe5 19. Qh8+ Kf7 20. Nxf8 Rxf8 21. Qh5+ Kg8 22. fxe6 Qxc3+ 0-1`
    }
];

// ============================================================
// Chess piece Unicode symbols
// ============================================================
const pieces = {
    'K': { symbol: '‚ôî', type: 'king' },
    'Q': { symbol: '‚ôï', type: 'queen' },
    'R': { symbol: '‚ôñ', type: 'rook' },
    'B': { symbol: '‚ôó', type: 'bishop' },
    'N': { symbol: '‚ôò', type: 'knight' },
    'P': { symbol: '‚ôô', type: 'pawn' },
    'k': { symbol: '‚ôö', type: 'king' },
    'q': { symbol: '‚ôõ', type: 'queen' },
    'r': { symbol: '‚ôú', type: 'rook' },
    'b': { symbol: '‚ôù', type: 'bishop' },
    'n': { symbol: '‚ôû', type: 'knight' },
    'p': { symbol: '‚ôü', type: 'pawn' }
};

// ============================================================
// Global Variables
// ============================================================
let chess = new Chess();
let gameTree = null;
let currentNode = null;
let gameInfo = {};
let isFlipped = false;
let analysisEnabled = false;
let engineWorker = null;
let engineReady = false;

// ============================================================
// PGN Parser - Creates hierarchical game tree
// ============================================================
class GameNode {
    constructor(move = null, preComment = null, postComment = null, parent = null) {
        this.move = move;
        this.preComment = preComment;
        this.postComment = postComment;
        this.parent = parent;
        this.children = [];
        this.variations = [];
        this.fen = null;
    }
    
    addChild(node) {
        this.children.push(node);
        return node;
    }
    
    addVariation(node) {
        this.variations.push(node);
        return node;
    }
}

function parsePGNHeaders(pgn) {
    const headerRegex = /\[(\w+)\s+"([^"]+)"\]/g;
    const info = {};
    let match;
    
    while ((match = headerRegex.exec(pgn)) !== null) {
        info[match[1]] = match[2];
    }
    
    return info;
}

function parsePGNMoves(pgn) {
    const movesText = pgn.replace(/\[.*?\]\s*/g, '');
    const root = new GameNode();
    root.fen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
    
    const tokens = tokenizePGN(movesText);
    buildGameTree(root, tokens, 0);
    
    return root;
}

function tokenizePGN(text) {
    const tokens = [];
    let i = 0;
    
    while (i < text.length) {
        while (i < text.length && /\s/.test(text[i])) i++;
        if (i >= text.length) break;
        
        if (text[i] === '{') {
            const start = i + 1;
            i++;
            while (i < text.length && text[i] !== '}') i++;
            tokens.push({ type: 'comment', value: text.substring(start, i).trim() });
            i++;
        }
        else if (text[i] === '(') {
            tokens.push({ type: 'var_start' });
            i++;
        }
        else if (text[i] === ')') {
            tokens.push({ type: 'var_end' });
            i++;
        }
        else if (text[i] === '$') {
            const start = i;
            i++;
            while (i < text.length && /\d/.test(text[i])) i++;
            tokens.push({ type: 'nag', value: text.substring(start, i) });
        }
        else if (/\d/.test(text[i])) {
            while (i < text.length && /[\d.]/.test(text[i])) i++;
        }
        else {
            const start = i;
            while (i < text.length && /[a-zA-Z0-9+#=\-]/.test(text[i])) i++;
            const value = text.substring(start, i);
            
            if (['1-0', '0-1', '1/2-1/2', '*'].includes(value)) {
                tokens.push({ type: 'result', value });
            } else {
                tokens.push({ type: 'move', value });
            }
        }
    }
    
    return tokens;
}

function buildGameTree(node, tokens, index) {
    const tempChess = new Chess(node.fen);
    let pendingPreComment = null;
    let i = index;
    
    while (i < tokens.length) {
        const token = tokens[i];
        
        if (token.type === 'comment') {
            pendingPreComment = token.value;
            i++;
        }
        else if (token.type === 'move') {
            try {
                const move = tempChess.move(token.value);
                if (move) {
                    // Check if next token is a comment (post-comment)
                    let postComment = null;
                    if (i + 1 < tokens.length && tokens[i + 1].type === 'comment') {
                        postComment = tokens[i + 1].value;
                        i++; // Skip the comment token
                    }
                    
                    const childNode = new GameNode(move, pendingPreComment, postComment, node);
                    childNode.fen = tempChess.fen();
                    node.addChild(childNode);
                    node = childNode;
                    pendingPreComment = null;
                }
            } catch (e) {
                console.error('Invalid move:', token.value, e);
            }
            i++;
        }
        else if (token.type === 'var_start') {
            if (node.parent) {
                const varNode = new GameNode(null, null, null, node.parent);
                varNode.fen = node.parent.fen;
                node.parent.addVariation(varNode);
                i = buildGameTree(varNode, tokens, i + 1);
            } else {
                i++;
            }
        }
        else if (token.type === 'var_end') {
            return i + 1;
        }
        else if (token.type === 'result') {
            i++;
        }
        else {
            i++;
        }
    }
    
    return i;
}

// ============================================================
// Stockfish Integration
// ============================================================
function startEngine() {
    try {
        document.getElementById('analysisStatus').textContent = 'Loading engine...';
        
        const sfUrl = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
        const blob = new Blob(['importScripts("' + sfUrl + '");'], {type: 'application/javascript'});
        engineWorker = new Worker(URL.createObjectURL(blob));
        
        engineWorker.onmessage = function(e) {
            parseEngineOutput(e.data);
        };
        
        engineWorker.onerror = function(e) {
            document.getElementById('analysisStatus').textContent = 'Error: ' + e.message;
        };
        
        engineWorker.postMessage('uci');
        engineWorker.postMessage('isready');
        
    } catch (error) {
        console.error('Failed to start engine:', error);
        document.getElementById('analysisStatus').textContent = 'Failed to load engine';
    }
}

function parseEngineOutput(message) {
    if (message === 'readyok') {
        engineReady = true;
        document.getElementById('analysisStatus').textContent = 'Engine ready';
        
        if (analysisEnabled) {
            analyzePosition();
        }
        return;
    }
    
    if (message.startsWith('info')) {
        const depthMatch = message.match(/\sdepth (\d+)/);
        if (depthMatch) {
            document.getElementById('analysisDepth').textContent = `Depth: ${depthMatch[1]}`;
            document.getElementById('analysisStatus').textContent = `Analyzing... depth ${depthMatch[1]}`;
        }
        
        const scoreMatch = message.match(/score cp (-?\d+)/);
        if (scoreMatch) {
            const centipawns = parseInt(scoreMatch[1]);
            const pawns = (centipawns / 100).toFixed(2);
            document.getElementById('analysisEval').textContent = `Evaluation: ${pawns > 0 ? '+' : ''}${pawns}`;
        }
        
        const mateMatch = message.match(/score mate (-?\d+)/);
        if (mateMatch) {
            const mateIn = parseInt(mateMatch[1]);
            if (mateIn > 0) {
                document.getElementById('analysisEval').textContent = `Evaluation: White mates in ${mateIn}`;
            } else {
                document.getElementById('analysisEval').textContent = `Evaluation: Black mates in ${Math.abs(mateIn)}`;
            }
        }
        
        const pvMatch = message.match(/pv ([a-h][1-8][a-h][1-8][qrbn]?)/);
        if (pvMatch) {
            document.getElementById('analysisBestMove').textContent = `Best move: ${pvMatch[1]}`;
        }
    }
    
    if (message.startsWith('bestmove')) {
        const moveMatch = message.match(/bestmove ([a-h][1-8][a-h][1-8][qrbn]?)/);
        if (moveMatch) {
            document.getElementById('analysisBestMove').textContent = `Best move: ${moveMatch[1]}`;
        }
        document.getElementById('analysisStatus').textContent = 'Analysis complete';
    }
}

function analyzePosition() {
    if (!engineWorker || !analysisEnabled || !engineReady) return;
    
    // Get the FEN from currentNode if available, otherwise use starting position
    const fen = currentNode ? currentNode.fen
        : 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
    
    document.getElementById('analysisStatus').textContent = 'Analyzing...';
    document.getElementById('analysisEval').textContent = 'Evaluation: --';
    document.getElementById('analysisBestMove').textContent = 'Best move: --';
    document.getElementById('analysisDepth').textContent = 'Depth: 0';
    
    try {
        engineWorker.postMessage('stop');
        engineWorker.postMessage('ucinewgame');
        engineWorker.postMessage('position fen ' + fen);
        engineWorker.postMessage('go depth 45');
    } catch (error) {
        console.error('Analysis error:', error);
        document.getElementById('analysisStatus').textContent = 'Analysis error';
    }
}

function toggleAnalysis() {
    const btn = document.getElementById('analysisBtn');
    const panel = document.getElementById('analysisPanel');
    
    if (!engineWorker) {
        panel.classList.add('active');
        startEngine();
    }
    
    analysisEnabled = !analysisEnabled;
    
    if (analysisEnabled) {
        btn.classList.add('active');
        btn.textContent = '‚úì Analysis ON';
        panel.classList.add('active');
        
        if (engineReady) {
            analyzePosition();
        }
    } else {
        btn.classList.remove('active');
        btn.textContent = 'üîç Analysis';
        panel.classList.remove('active');
        
        if (engineWorker) {
            engineWorker.postMessage('stop');
        }
    }
}

// ============================================================
// Display Functions
// ============================================================
function displayGameInfo(info) {
    const gameInfoDiv = document.getElementById('gameInfo');
    let hasInfo = false;
    let html = '';
    
    if (info.Event) {
        html += `<p><strong>Event:</strong> ${info.Event}</p>`;
        hasInfo = true;
    }
    if (info.White) {
        html += `<p><strong>White:</strong> ${info.White}</p>`;
        hasInfo = true;
    }
    if (info.Black) {
        html += `<p><strong>Black:</strong> ${info.Black}</p>`;
        hasInfo = true;
    }
    if (info.Result) {
        html += `<p><strong>Result:</strong> ${info.Result}</p>`;
        hasInfo = true;
    }
    if (info.Date) {
        html += `<p><strong>Date:</strong> ${info.Date}</p>`;
        hasInfo = true;
    }
    if (info.Site) {
        html += `<p><strong>Site:</strong> ${info.Site}</p>`;
        hasInfo = true;
    }
    
    if (hasInfo) {
        gameInfoDiv.innerHTML = html;
        gameInfoDiv.style.display = 'block';
    } else {
        gameInfoDiv.style.display = 'none';
    }
}

function displayMoves() {
    const movesDiv = document.getElementById('movesDisplay');
    movesDiv.innerHTML = '';
    
    if (!gameTree) return;
    
    displayMovesRecursive(gameTree, movesDiv, 1, false);
}

function displayMovesRecursive(node, container, moveNumber, isVariation) {
    node.children.forEach((child, index) => {
        // Display pre-comment if exists
        if (child.preComment) {
            const preCommentSpan = document.createElement('span');
            preCommentSpan.className = 'move-comment';
            preCommentSpan.textContent = child.preComment + ' ';
            container.appendChild(preCommentSpan);
        }
        
        // Display move number
        if (child.move.color === 'w') {
            const numSpan = document.createElement('span');
            numSpan.className = 'move-number';
            numSpan.textContent = `${moveNumber}.`;
            container.appendChild(numSpan);
        } else {
            // Black move: show N... only when flow was interrupted
            const needsNumber =
                node.move === null ||           // start of game or variation
                child.preComment !== null ||    // this Black move has a pre-comment
                node.postComment !== null ||    // preceding White move had a post-comment
                node.variations.length > 0;    // preceding White move had variations after it

            if (needsNumber) {
                const numSpan = document.createElement('span');
                numSpan.className = 'move-number';
                numSpan.textContent = `${moveNumber}...`;
                container.appendChild(numSpan);
            }
        }
        
        // Display the move
        let moveClass = 'move' + (isVariation ? ' variation' : '');
        if (child === currentNode) {
            moveClass += ' current';
        }
        
        const moveSpan = document.createElement('span');
        moveSpan.className = moveClass;
        moveSpan.textContent = child.move.san;
        moveSpan.onclick = () => goToNode(child);
        container.appendChild(moveSpan);
        
        // Display post-comment if exists
        if (child.postComment) {
            const postCommentSpan = document.createElement('span');
            postCommentSpan.className = 'move-comment';
            postCommentSpan.textContent = child.postComment + ' ';
            container.appendChild(postCommentSpan);
        }
        
        // Display variations immediately after this move
        child.variations.forEach(varNode => {
            const varDiv = document.createElement('span');
            varDiv.className = 'variation-group';
            container.appendChild(varDiv);
            
            varDiv.appendChild(document.createTextNode('('));
            displayMovesRecursive(varNode, varDiv, 
                child.move.color === 'w' ? moveNumber : moveNumber + 1, true);
            varDiv.appendChild(document.createTextNode(') '));
        });
        
        // Continue with main line
        const nextMoveNumber = child.move.color === 'b' ? moveNumber + 1 : moveNumber;
        displayMovesRecursive(child, container, nextMoveNumber, isVariation);
    });
}

// ============================================================
// Board Functions
// ============================================================
function initBoard() {
    const board = document.getElementById('chessboard');
    board.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            const actualRow = isFlipped ? row : 7 - row;
            const actualCol = isFlipped ? 7 - col : col;
            
            square.className = 'square ' + ((actualRow + actualCol) % 2 === 0 ? 'light' : 'dark');
            square.dataset.row = actualRow;
            square.dataset.col = actualCol;
            board.appendChild(square);
        }
    }
    
    updateBoard();
}

function updateBoard() {
    const squares = document.querySelectorAll('.square');
    
    // Use currentNode FEN if available, otherwise show starting position
    const fen = currentNode
        ? currentNode.fen
        : 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
    
    chess.load(fen);
    const position = chess.board();
    
    squares.forEach(square => {
        square.innerHTML = '';
        square.classList.remove('highlight');
    });
    
    // Highlight the last move if one exists
    if (currentNode && currentNode.move) {
        const fromSquare = currentNode.move.from;
        const toSquare = currentNode.move.to;
        
        const fromFile = fromSquare.charCodeAt(0) - 97;
        const fromRank = parseInt(fromSquare[1]) - 1;
        const toFile = toSquare.charCodeAt(0) - 97;
        const toRank = parseInt(toSquare[1]) - 1;
        
        const fromRow = isFlipped ? fromRank : 7 - fromRank;
        const fromCol = isFlipped ? 7 - fromFile : fromFile;
        const toRow = isFlipped ? toRank : 7 - toRank;
        const toCol = isFlipped ? 7 - toFile : toFile;
        
        squares[fromRow * 8 + fromCol].classList.add('highlight');
        squares[toRow * 8 + toCol].classList.add('highlight');
    }
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = position[row][col];
            if (piece) {
                const actualRow = isFlipped ? 7 - row : row;
                const actualCol = isFlipped ? 7 - col : col;
                const index = actualRow * 8 + actualCol;
                
                const pieceChar = piece.color === 'w' ? piece.type.toUpperCase() : piece.type;
                const pieceData = pieces[pieceChar];
                
                if (pieceData) {
                    const pieceSpan = document.createElement('span');
                    pieceSpan.textContent = pieceData.symbol;
                    pieceSpan.className = 'piece-' + pieceData.type;
                    squares[index].appendChild(pieceSpan);
                }
            }
        }
    }
}

// ============================================================
// Navigation Functions
// ============================================================
function goToNode(node) {
    currentNode = node;
    updateBoard();
    displayMoves();
    updateButtons();
    
    if (analysisEnabled && engineReady) {
        analyzePosition();
    }
}

function goToStart() {
    if (gameTree) {
        currentNode = gameTree;
        updateBoard();
        displayMoves();
        updateButtons();
        
        if (analysisEnabled && engineReady) {
            analyzePosition();
        }
    }
}

function goToPrevious() {
    if (currentNode && currentNode.parent) {
        goToNode(currentNode.parent);
    }
}

function goToNext() {
    if (currentNode && currentNode.children.length > 0) {
        goToNode(currentNode.children[0]);
    }
}

function goToEnd() {
    if (!currentNode) return;
    
    let node = currentNode;
    while (node.children.length > 0) {
        node = node.children[0];
    }
    goToNode(node);
}

function flipBoard() {
    isFlipped = !isFlipped;
    initBoard();
}

function updateButtons() {
    document.getElementById('startBtn').disabled = !currentNode || !currentNode.parent;
    document.getElementById('prevBtn').disabled = !currentNode || !currentNode.parent;
    document.getElementById('nextBtn').disabled = !currentNode || currentNode.children.length === 0;
    document.getElementById('endBtn').disabled = !currentNode || currentNode.children.length === 0;
}

// ============================================================
// Load Game
// ============================================================
function stripCommentsFromPGN(pgn) {
    let cleaned = pgn.replace(/\{[^}]*\}/g, '');
    cleaned = cleaned.replace(/\s+/g, ' ').trim();
    return cleaned;
}

function isValidPGN(pgn) {
    // Use chess.js to validate before we try to parse it ourselves
    try {
        const testChess = new Chess();
        // Strip comments and variations for validation purposes only
        let stripped = pgn.replace(/\{[^}]*\}/g, '');
        stripped = stripped.replace(/\([^)]*\)/g, '');
        stripped = stripped.replace(/$\d+/g, '');
        // Must have at least one move-like token (letter followed by chess chars)
        if (!/[KQRBN]?[a-h]?[1-8]?x?[a-h][1-8]|O-O/.test(stripped)) {
            return false;
        }
        return testChess.load_pgn(stripped);
    } catch (e) {
        return false;
    }
}

function loadGame() {
    const pgn = document.getElementById('pgnInput').value.trim();
    
    if (!pgn) {
        alert('Please paste a PGN notation or select a game first.');
        return;
    }
    
    if (!isValidPGN(pgn)) {
        clearPGN();
        return;
    }
    
    try {
        gameInfo = parsePGNHeaders(pgn);
        gameTree = parsePGNMoves(pgn);
        currentNode = gameTree;
        
        displayGameInfo(gameInfo);
        displayMoves();
        goToStart();
        
        // Reset Stockfish for new game
        if (analysisEnabled && engineReady) {
            analyzePosition();
        }
        
    } catch (error) {
        console.error('PGN Error:', error);
        clearPGN();
    }
}

function clearPGN() {
    document.getElementById('pgnInput').value = '';
    document.getElementById('gameSelect').selectedIndex = 0;
    document.getElementById('gameInfo').style.display = 'none';
    document.getElementById('movesDisplay').innerHTML = '';
    gameTree = null;
    currentNode = null;
    gameInfo = {};
    
    initBoard(); // Will show starting position since currentNode is null
    updateButtons();
    
    // Reset analysis display and re-analyze starting position
    document.getElementById('analysisEval').textContent = 'Evaluation: --';
    document.getElementById('analysisBestMove').textContent = 'Best move: --';
    document.getElementById('analysisDepth').textContent = 'Depth: 0';
    
    if (analysisEnabled && engineReady) {
        analyzePosition();
    }
}

// ============================================================
// Game Database Functions
// ============================================================
function populateGameSelector() {
    const select = document.getElementById('gameSelect');
    
    GAME_DATABASE.forEach((game, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = game.name;
        select.appendChild(option);
    });
}

function loadSelectedGame() {
    const select = document.getElementById('gameSelect');
    const selectedIndex = select.value;
    
    if (selectedIndex === '') {
        return;
    }
    
    const game = GAME_DATABASE[selectedIndex];
    document.getElementById('pgnInput').value = game.pgn;
    loadGame();
}

// ============================================================
// Event Listeners
// ============================================================
document.getElementById('gameSelect').addEventListener('change', loadSelectedGame);
document.getElementById('loadBtn').addEventListener('click', loadGame);
document.getElementById('clearBtn').addEventListener('click', clearPGN);
document.getElementById('startBtn').addEventListener('click', goToStart);
document.getElementById('prevBtn').addEventListener('click', goToPrevious);
document.getElementById('nextBtn').addEventListener('click', goToNext);
document.getElementById('endBtn').addEventListener('click', goToEnd);
document.getElementById('flipBtn').addEventListener('click', flipBoard);
document.getElementById('analysisBtn').addEventListener('click', toggleAnalysis);

document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') goToPrevious();
    if (e.key === 'ArrowRight') goToNext();
    if (e.key === 'Home') goToStart();
    if (e.key === 'End') goToEnd();
});

// ============================================================
// Initialize
// ============================================================
populateGameSelector();
initBoard();
updateButtons();
</script>
</body>
</html>
